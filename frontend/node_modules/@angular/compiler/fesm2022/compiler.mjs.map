{"version":3,"file":"compiler.mjs","sources":["../../../../../../packages/compiler/src/selector.ts","../../../../../../packages/compiler/src/core.ts","../../../../../../packages/compiler/src/i18n/digest.ts","../../../../../../packages/compiler/src/output/output_ast.ts","../../../../../../packages/compiler/src/constant_pool.ts","../../../../../../packages/compiler/src/render3/r3_identifiers.ts","../../../../../../packages/compiler/src/util.ts","../../../../../../packages/compiler/src/output/source_map.ts","../../../../../../packages/compiler/src/output/abstract_emitter.ts","../../../../../../packages/compiler/src/render3/util.ts","../../../../../../packages/compiler/src/render3/r3_factory.ts","../../../../../../packages/compiler/src/expression_parser/ast.ts","../../../../../../packages/compiler/src/ml_parser/tags.ts","../../../../../../packages/compiler/src/render3/r3_ast.ts","../../../../../../packages/compiler/src/i18n/i18n_ast.ts","../../../../../../packages/compiler/src/i18n/serializers/serializer.ts","../../../../../../packages/compiler/src/i18n/serializers/xml_helper.ts","../../../../../../packages/compiler/src/i18n/serializers/xmb.ts","../../../../../../packages/compiler/src/render3/view/i18n/util.ts","../../../../../../packages/compiler/src/render3/view/util.ts","../../../../../../packages/compiler/src/injectable_compiler_2.ts","../../../../../../packages/compiler/src/assertions.ts","../../../../../../packages/compiler/src/ml_parser/defaults.ts","../../../../../../packages/compiler/src/chars.ts","../../../../../../packages/compiler/src/parse_util.ts","../../../../../../packages/compiler/src/output/abstract_js_emitter.ts","../../../../../../packages/compiler/src/output/output_jit_trusted_types.ts","../../../../../../packages/compiler/src/output/output_jit.ts","../../../../../../packages/compiler/src/render3/r3_injector_compiler.ts","../../../../../../packages/compiler/src/render3/r3_jit.ts","../../../../../../packages/compiler/src/render3/r3_module_compiler.ts","../../../../../../packages/compiler/src/render3/r3_pipe_compiler.ts","../../../../../../packages/compiler/src/render3/view/api.ts","../../../../../../packages/compiler/src/shadow_css.ts","../../../../../../packages/compiler/src/template/pipeline/ir/src/enums.ts","../../../../../../packages/compiler/src/template/pipeline/ir/src/traits.ts","../../../../../../packages/compiler/src/template/pipeline/ir/src/ops/shared.ts","../../../../../../packages/compiler/src/template/pipeline/ir/src/ops/update.ts","../../../../../../packages/compiler/src/template/pipeline/ir/src/expression.ts","../../../../../../packages/compiler/src/template/pipeline/ir/src/operations.ts","../../../../../../packages/compiler/src/template/pipeline/ir/src/handle.ts","../../../../../../packages/compiler/src/template/pipeline/ir/src/ops/create.ts","../../../../../../packages/compiler/src/template/pipeline/ir/src/ops/host.ts","../../../../../../packages/compiler/src/template/pipeline/ir/src/variable.ts","../../../../../../packages/compiler/src/template/pipeline/src/compilation.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/any_cast.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/apply_i18n_expressions.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/assign_i18n_slot_dependencies.ts","../../../../../../packages/compiler/src/template/pipeline/src/util/elements.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/attribute_extraction.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/binding_specialization.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/chaining.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/collapse_singleton_interpolations.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/conditionals.ts","../../../../../../packages/compiler/src/template/pipeline/src/conversion.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/const_collection.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/convert_i18n_bindings.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/resolve_defer_deps_fns.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/create_i18n_contexts.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/deduplicate_text_bindings.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/defer_configs.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/defer_resolve_targets.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/empty_elements.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/expand_safe_reads.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/extract_i18n_messages.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/generate_advance.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/generate_projection_def.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/generate_variables.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/has_const_expression_collection.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/host_style_property_parsing.ts","../../../../../../packages/compiler/src/output/map_util.ts","../../../../../../packages/compiler/src/render3/view/i18n/icu_serializer.ts","../../../../../../packages/compiler/src/ml_parser/ast.ts","../../../../../../packages/compiler/src/ml_parser/entities.ts","../../../../../../packages/compiler/src/ml_parser/lexer.ts","../../../../../../packages/compiler/src/ml_parser/parser.ts","../../../../../../packages/compiler/src/ml_parser/html_whitespaces.ts","../../../../../../packages/compiler/src/expression_parser/lexer.ts","../../../../../../packages/compiler/src/expression_parser/parser.ts","../../../../../../packages/compiler/src/expression_parser/serializer.ts","../../../../../../packages/compiler/src/schema/dom_security_schema.ts","../../../../../../packages/compiler/src/schema/element_schema_registry.ts","../../../../../../packages/compiler/src/schema/dom_element_schema_registry.ts","../../../../../../packages/compiler/src/ml_parser/html_tags.ts","../../../../../../packages/compiler/src/i18n/serializers/placeholder.ts","../../../../../../packages/compiler/src/i18n/i18n_parser.ts","../../../../../../packages/compiler/src/i18n/parse_util.ts","../../../../../../packages/compiler/src/schema/trusted_types_sinks.ts","../../../../../../packages/compiler/src/render3/view/i18n/meta.ts","../../../../../../packages/compiler/src/render3/view/i18n/get_msg_utils.ts","../../../../../../packages/compiler/src/render3/view/i18n/localize_utils.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/i18n_const_collection.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/i18n_text_extraction.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/local_refs.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/namespace.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/parse_extracted_styles.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/naming.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/next_context_merging.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/ng_container.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/nonbindable.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/nullish_coalescing.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/ordering.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/phase_remove_content_selectors.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/pipe_creation.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/pipe_variadic.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/propagate_i18n_blocks.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/pure_function_extraction.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/pure_literal_structures.ts","../../../../../../packages/compiler/src/template/pipeline/src/instruction.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/reify.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/remove_empty_bindings.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/remove_i18n_contexts.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/remove_unused_i18n_attrs.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/resolve_contexts.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/resolve_dollar_event.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/resolve_i18n_element_placeholders.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/resolve_i18n_expression_placeholders.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/resolve_names.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/resolve_sanitizers.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/transform_two_way_binding_set.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/save_restore_view.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/slot_allocation.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/style_binding_specialization.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/temporary_variables.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/track_fn_optimization.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/track_variables.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/var_counting.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/variable_optimization.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/wrap_icus.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/store_let_optimization.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/remove_illegal_let_references.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/generate_local_let_references.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/attach_source_locations.ts","../../../../../../packages/compiler/src/template/pipeline/src/emit.ts","../../../../../../packages/compiler/src/template/pipeline/src/ingest.ts","../../../../../../packages/compiler/src/render3/view/config.ts","../../../../../../packages/compiler/src/render3/view/query_generation.ts","../../../../../../packages/compiler/src/ml_parser/html_parser.ts","../../../../../../packages/compiler/src/template_parser/binding_parser.ts","../../../../../../packages/compiler/src/style_url_resolver.ts","../../../../../../packages/compiler/src/template_parser/template_preparser.ts","../../../../../../packages/compiler/src/render3/r3_control_flow.ts","../../../../../../packages/compiler/src/render3/r3_deferred_triggers.ts","../../../../../../packages/compiler/src/render3/r3_deferred_blocks.ts","../../../../../../packages/compiler/src/render3/r3_template_transform.ts","../../../../../../packages/compiler/src/render3/view/template.ts","../../../../../../packages/compiler/src/render3/view/compiler.ts","../../../../../../packages/compiler/src/render3/view/t2_binder.ts","../../../../../../packages/compiler/src/resource_loader.ts","../../../../../../packages/compiler/src/jit_compiler_facade.ts","../../../../../../packages/compiler/src/version.ts","../../../../../../packages/compiler/src/config.ts","../../../../../../packages/compiler/src/i18n/extractor_merger.ts","../../../../../../packages/compiler/src/ml_parser/xml_tags.ts","../../../../../../packages/compiler/src/ml_parser/xml_parser.ts","../../../../../../packages/compiler/src/i18n/serializers/xliff.ts","../../../../../../packages/compiler/src/i18n/serializers/xliff2.ts","../../../../../../packages/compiler/src/i18n/serializers/xtb.ts","../../../../../../packages/compiler/src/i18n/translation_bundle.ts","../../../../../../packages/compiler/src/i18n/i18n_html_parser.ts","../../../../../../packages/compiler/src/i18n/message_bundle.ts","../../../../../../packages/compiler/src/render3/partial/api.ts","../../../../../../packages/compiler/src/render3/r3_class_metadata_compiler.ts","../../../../../../packages/compiler/src/render3/r3_class_debug_info_compiler.ts","../../../../../../packages/compiler/src/render3/r3_hmr_compiler.ts","../../../../../../packages/compiler/src/render3/partial/class_metadata.ts","../../../../../../packages/compiler/src/render3/partial/util.ts","../../../../../../packages/compiler/src/render3/partial/directive.ts","../../../../../../packages/compiler/src/render3/partial/component.ts","../../../../../../packages/compiler/src/render3/partial/factory.ts","../../../../../../packages/compiler/src/render3/partial/injectable.ts","../../../../../../packages/compiler/src/render3/partial/injector.ts","../../../../../../packages/compiler/src/render3/partial/ng_module.ts","../../../../../../packages/compiler/src/render3/partial/pipe.ts","../../../../../../packages/compiler/src/compiler.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nconst _SELECTOR_REGEXP = new RegExp(\n  '(\\\\:not\\\\()|' + // 1: \":not(\"\n    '(([\\\\.\\\\#]?)[-\\\\w]+)|' + // 2: \"tag\"; 3: \".\"/\"#\";\n    // \"-\" should appear first in the regexp below as FF31 parses \"[.-\\w]\" as a range\n    // 4: attribute; 5: attribute_string; 6: attribute_value\n    '(?:\\\\[([-.\\\\w*\\\\\\\\$]+)(?:=([\"\\']?)([^\\\\]\"\\']*)\\\\5)?\\\\])|' + // \"[name]\", \"[name=value]\",\n    // \"[name=\"value\"]\",\n    // \"[name='value']\"\n    '(\\\\))|' + // 7: \")\"\n    '(\\\\s*,\\\\s*)', // 8: \",\"\n  'g',\n);\n\n/**\n * These offsets should match the match-groups in `_SELECTOR_REGEXP` offsets.\n */\nconst enum SelectorRegexp {\n  ALL = 0, // The whole match\n  NOT = 1,\n  TAG = 2,\n  PREFIX = 3,\n  ATTRIBUTE = 4,\n  ATTRIBUTE_STRING = 5,\n  ATTRIBUTE_VALUE = 6,\n  NOT_END = 7,\n  SEPARATOR = 8,\n}\n/**\n * A css selector contains an element name,\n * css classes and attribute/value pairs with the purpose\n * of selecting subsets out of them.\n */\nexport class CssSelector {\n  element: string | null = null;\n  classNames: string[] = [];\n  /**\n   * The selectors are encoded in pairs where:\n   * - even locations are attribute names\n   * - odd locations are attribute values.\n   *\n   * Example:\n   * Selector: `[key1=value1][key2]` would parse to:\n   * ```\n   * ['key1', 'value1', 'key2', '']\n   * ```\n   */\n  attrs: string[] = [];\n  notSelectors: CssSelector[] = [];\n\n  static parse(selector: string): CssSelector[] {\n    const results: CssSelector[] = [];\n    const _addResult = (res: CssSelector[], cssSel: CssSelector) => {\n      if (\n        cssSel.notSelectors.length > 0 &&\n        !cssSel.element &&\n        cssSel.classNames.length == 0 &&\n        cssSel.attrs.length == 0\n      ) {\n        cssSel.element = '*';\n      }\n      res.push(cssSel);\n    };\n    let cssSelector = new CssSelector();\n    let match: string[] | null;\n    let current = cssSelector;\n    let inNot = false;\n    _SELECTOR_REGEXP.lastIndex = 0;\n    while ((match = _SELECTOR_REGEXP.exec(selector))) {\n      if (match[SelectorRegexp.NOT]) {\n        if (inNot) {\n          throw new Error('Nesting :not in a selector is not allowed');\n        }\n        inNot = true;\n        current = new CssSelector();\n        cssSelector.notSelectors.push(current);\n      }\n      const tag = match[SelectorRegexp.TAG];\n      if (tag) {\n        const prefix = match[SelectorRegexp.PREFIX];\n        if (prefix === '#') {\n          // #hash\n          current.addAttribute('id', tag.slice(1));\n        } else if (prefix === '.') {\n          // Class\n          current.addClassName(tag.slice(1));\n        } else {\n          // Element\n          current.setElement(tag);\n        }\n      }\n      const attribute = match[SelectorRegexp.ATTRIBUTE];\n\n      if (attribute) {\n        current.addAttribute(\n          current.unescapeAttribute(attribute),\n          match[SelectorRegexp.ATTRIBUTE_VALUE],\n        );\n      }\n      if (match[SelectorRegexp.NOT_END]) {\n        inNot = false;\n        current = cssSelector;\n      }\n      if (match[SelectorRegexp.SEPARATOR]) {\n        if (inNot) {\n          throw new Error('Multiple selectors in :not are not supported');\n        }\n        _addResult(results, cssSelector);\n        cssSelector = current = new CssSelector();\n      }\n    }\n    _addResult(results, cssSelector);\n    return results;\n  }\n\n  /**\n   * Unescape `\\$` sequences from the CSS attribute selector.\n   *\n   * This is needed because `$` can have a special meaning in CSS selectors,\n   * but we might want to match an attribute that contains `$`.\n   * [MDN web link for more\n   * info](https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors).\n   * @param attr the attribute to unescape.\n   * @returns the unescaped string.\n   */\n  unescapeAttribute(attr: string): string {\n    let result = '';\n    let escaping = false;\n    for (let i = 0; i < attr.length; i++) {\n      const char = attr.charAt(i);\n      if (char === '\\\\') {\n        escaping = true;\n        continue;\n      }\n      if (char === '$' && !escaping) {\n        throw new Error(\n          `Error in attribute selector \"${attr}\". ` +\n            `Unescaped \"$\" is not supported. Please escape with \"\\\\$\".`,\n        );\n      }\n      escaping = false;\n      result += char;\n    }\n    return result;\n  }\n\n  /**\n   * Escape `$` sequences from the CSS attribute selector.\n   *\n   * This is needed because `$` can have a special meaning in CSS selectors,\n   * with this method we are escaping `$` with `\\$'.\n   * [MDN web link for more\n   * info](https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors).\n   * @param attr the attribute to escape.\n   * @returns the escaped string.\n   */\n  escapeAttribute(attr: string): string {\n    return attr.replace(/\\\\/g, '\\\\\\\\').replace(/\\$/g, '\\\\$');\n  }\n\n  isElementSelector(): boolean {\n    return (\n      this.hasElementSelector() &&\n      this.classNames.length == 0 &&\n      this.attrs.length == 0 &&\n      this.notSelectors.length === 0\n    );\n  }\n\n  hasElementSelector(): boolean {\n    return !!this.element;\n  }\n\n  setElement(element: string | null = null) {\n    this.element = element;\n  }\n\n  getAttrs(): string[] {\n    const result: string[] = [];\n    if (this.classNames.length > 0) {\n      result.push('class', this.classNames.join(' '));\n    }\n    return result.concat(this.attrs);\n  }\n\n  addAttribute(name: string, value: string = '') {\n    this.attrs.push(name, (value && value.toLowerCase()) || '');\n  }\n\n  addClassName(name: string) {\n    this.classNames.push(name.toLowerCase());\n  }\n\n  toString(): string {\n    let res: string = this.element || '';\n    if (this.classNames) {\n      this.classNames.forEach((klass) => (res += `.${klass}`));\n    }\n    if (this.attrs) {\n      for (let i = 0; i < this.attrs.length; i += 2) {\n        const name = this.escapeAttribute(this.attrs[i]);\n        const value = this.attrs[i + 1];\n        res += `[${name}${value ? '=' + value : ''}]`;\n      }\n    }\n    this.notSelectors.forEach((notSelector) => (res += `:not(${notSelector})`));\n    return res;\n  }\n}\n\n/**\n * Reads a list of CssSelectors and allows to calculate which ones\n * are contained in a given CssSelector.\n */\nexport class SelectorMatcher<T = any> {\n  static createNotMatcher(notSelectors: CssSelector[]): SelectorMatcher<null> {\n    const notMatcher = new SelectorMatcher<null>();\n    notMatcher.addSelectables(notSelectors, null);\n    return notMatcher;\n  }\n\n  private _elementMap = new Map<string, SelectorContext<T>[]>();\n  private _elementPartialMap = new Map<string, SelectorMatcher<T>>();\n  private _classMap = new Map<string, SelectorContext<T>[]>();\n  private _classPartialMap = new Map<string, SelectorMatcher<T>>();\n  private _attrValueMap = new Map<string, Map<string, SelectorContext<T>[]>>();\n  private _attrValuePartialMap = new Map<string, Map<string, SelectorMatcher<T>>>();\n  private _listContexts: SelectorListContext[] = [];\n\n  addSelectables(cssSelectors: CssSelector[], callbackCtxt?: T) {\n    let listContext: SelectorListContext = null!;\n    if (cssSelectors.length > 1) {\n      listContext = new SelectorListContext(cssSelectors);\n      this._listContexts.push(listContext);\n    }\n    for (let i = 0; i < cssSelectors.length; i++) {\n      this._addSelectable(cssSelectors[i], callbackCtxt as T, listContext);\n    }\n  }\n\n  /**\n   * Add an object that can be found later on by calling `match`.\n   * @param cssSelector A css selector\n   * @param callbackCtxt An opaque object that will be given to the callback of the `match` function\n   */\n  private _addSelectable(\n    cssSelector: CssSelector,\n    callbackCtxt: T,\n    listContext: SelectorListContext,\n  ) {\n    let matcher: SelectorMatcher<T> = this;\n    const element = cssSelector.element;\n    const classNames = cssSelector.classNames;\n    const attrs = cssSelector.attrs;\n    const selectable = new SelectorContext(cssSelector, callbackCtxt, listContext);\n\n    if (element) {\n      const isTerminal = attrs.length === 0 && classNames.length === 0;\n      if (isTerminal) {\n        this._addTerminal(matcher._elementMap, element, selectable);\n      } else {\n        matcher = this._addPartial(matcher._elementPartialMap, element);\n      }\n    }\n\n    if (classNames) {\n      for (let i = 0; i < classNames.length; i++) {\n        const isTerminal = attrs.length === 0 && i === classNames.length - 1;\n        const className = classNames[i];\n        if (isTerminal) {\n          this._addTerminal(matcher._classMap, className, selectable);\n        } else {\n          matcher = this._addPartial(matcher._classPartialMap, className);\n        }\n      }\n    }\n\n    if (attrs) {\n      for (let i = 0; i < attrs.length; i += 2) {\n        const isTerminal = i === attrs.length - 2;\n        const name = attrs[i];\n        const value = attrs[i + 1];\n        if (isTerminal) {\n          const terminalMap = matcher._attrValueMap;\n          let terminalValuesMap = terminalMap.get(name);\n          if (!terminalValuesMap) {\n            terminalValuesMap = new Map<string, SelectorContext<T>[]>();\n            terminalMap.set(name, terminalValuesMap);\n          }\n          this._addTerminal(terminalValuesMap, value, selectable);\n        } else {\n          const partialMap = matcher._attrValuePartialMap;\n          let partialValuesMap = partialMap.get(name);\n          if (!partialValuesMap) {\n            partialValuesMap = new Map<string, SelectorMatcher<T>>();\n            partialMap.set(name, partialValuesMap);\n          }\n          matcher = this._addPartial(partialValuesMap, value);\n        }\n      }\n    }\n  }\n\n  private _addTerminal(\n    map: Map<string, SelectorContext<T>[]>,\n    name: string,\n    selectable: SelectorContext<T>,\n  ) {\n    let terminalList = map.get(name);\n    if (!terminalList) {\n      terminalList = [];\n      map.set(name, terminalList);\n    }\n    terminalList.push(selectable);\n  }\n\n  private _addPartial(map: Map<string, SelectorMatcher<T>>, name: string): SelectorMatcher<T> {\n    let matcher = map.get(name);\n    if (!matcher) {\n      matcher = new SelectorMatcher<T>();\n      map.set(name, matcher);\n    }\n    return matcher;\n  }\n\n  /**\n   * Find the objects that have been added via `addSelectable`\n   * whose css selector is contained in the given css selector.\n   * @param cssSelector A css selector\n   * @param matchedCallback This callback will be called with the object handed into `addSelectable`\n   * @return boolean true if a match was found\n   */\n  match(\n    cssSelector: CssSelector,\n    matchedCallback: ((c: CssSelector, a: T) => void) | null,\n  ): boolean {\n    let result = false;\n    const element = cssSelector.element!;\n    const classNames = cssSelector.classNames;\n    const attrs = cssSelector.attrs;\n\n    for (let i = 0; i < this._listContexts.length; i++) {\n      this._listContexts[i].alreadyMatched = false;\n    }\n\n    result = this._matchTerminal(this._elementMap, element, cssSelector, matchedCallback) || result;\n    result =\n      this._matchPartial(this._elementPartialMap, element, cssSelector, matchedCallback) || result;\n\n    if (classNames) {\n      for (let i = 0; i < classNames.length; i++) {\n        const className = classNames[i];\n        result =\n          this._matchTerminal(this._classMap, className, cssSelector, matchedCallback) || result;\n        result =\n          this._matchPartial(this._classPartialMap, className, cssSelector, matchedCallback) ||\n          result;\n      }\n    }\n\n    if (attrs) {\n      for (let i = 0; i < attrs.length; i += 2) {\n        const name = attrs[i];\n        const value = attrs[i + 1];\n\n        const terminalValuesMap = this._attrValueMap.get(name)!;\n        if (value) {\n          result =\n            this._matchTerminal(terminalValuesMap, '', cssSelector, matchedCallback) || result;\n        }\n        result =\n          this._matchTerminal(terminalValuesMap, value, cssSelector, matchedCallback) || result;\n\n        const partialValuesMap = this._attrValuePartialMap.get(name)!;\n        if (value) {\n          result = this._matchPartial(partialValuesMap, '', cssSelector, matchedCallback) || result;\n        }\n        result =\n          this._matchPartial(partialValuesMap, value, cssSelector, matchedCallback) || result;\n      }\n    }\n    return result;\n  }\n\n  /** @internal */\n  _matchTerminal(\n    map: Map<string, SelectorContext<T>[]>,\n    name: string,\n    cssSelector: CssSelector,\n    matchedCallback: ((c: CssSelector, a: any) => void) | null,\n  ): boolean {\n    if (!map || typeof name !== 'string') {\n      return false;\n    }\n\n    let selectables: SelectorContext<T>[] = map.get(name) || [];\n    const starSelectables: SelectorContext<T>[] = map.get('*')!;\n    if (starSelectables) {\n      selectables = selectables.concat(starSelectables);\n    }\n    if (selectables.length === 0) {\n      return false;\n    }\n    let selectable: SelectorContext<T>;\n    let result = false;\n    for (let i = 0; i < selectables.length; i++) {\n      selectable = selectables[i];\n      result = selectable.finalize(cssSelector, matchedCallback) || result;\n    }\n    return result;\n  }\n\n  /** @internal */\n  _matchPartial(\n    map: Map<string, SelectorMatcher<T>>,\n    name: string,\n    cssSelector: CssSelector,\n    matchedCallback: ((c: CssSelector, a: any) => void) | null,\n  ): boolean {\n    if (!map || typeof name !== 'string') {\n      return false;\n    }\n\n    const nestedSelector = map.get(name);\n    if (!nestedSelector) {\n      return false;\n    }\n    // TODO(perf): get rid of recursion and measure again\n    // TODO(perf): don't pass the whole selector into the recursion,\n    // but only the not processed parts\n    return nestedSelector.match(cssSelector, matchedCallback);\n  }\n}\n\nexport class SelectorListContext {\n  alreadyMatched: boolean = false;\n\n  constructor(public selectors: CssSelector[]) {}\n}\n\n// Store context to pass back selector and context when a selector is matched\nexport class SelectorContext<T = any> {\n  notSelectors: CssSelector[];\n\n  constructor(\n    public selector: CssSelector,\n    public cbContext: T,\n    public listContext: SelectorListContext,\n  ) {\n    this.notSelectors = selector.notSelectors;\n  }\n\n  finalize(cssSelector: CssSelector, callback: ((c: CssSelector, a: T) => void) | null): boolean {\n    let result = true;\n    if (this.notSelectors.length > 0 && (!this.listContext || !this.listContext.alreadyMatched)) {\n      const notMatcher = SelectorMatcher.createNotMatcher(this.notSelectors);\n      result = !notMatcher.match(cssSelector, null);\n    }\n    if (result && callback && (!this.listContext || !this.listContext.alreadyMatched)) {\n      if (this.listContext) {\n        this.listContext.alreadyMatched = true;\n      }\n      callback(this.selector, this.cbContext);\n    }\n    return result;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n// Attention:\n// This file duplicates types and values from @angular/core\n// so that we are able to make @angular/compiler independent of @angular/core.\n// This is important to prevent a build cycle, as @angular/core needs to\n// be compiled with the compiler.\n\nimport {CssSelector} from './selector';\n\n// Stores the default value of `emitDistinctChangesOnly` when the `emitDistinctChangesOnly` is not\n// explicitly set.\nexport const emitDistinctChangesOnlyDefaultValue = true;\n\nexport enum ViewEncapsulation {\n  Emulated = 0,\n  // Historically the 1 value was for `Native` encapsulation which has been removed as of v11.\n  None = 2,\n  ShadowDom = 3,\n}\n\nexport enum ChangeDetectionStrategy {\n  OnPush = 0,\n  Default = 1,\n}\n\nexport interface Input {\n  alias?: string;\n  required?: boolean;\n  transform?: (value: any) => any;\n  // Note: This field is marked as `internal` in `@angular/core`, but in the compiler\n  // we rely on it for JIT processing at runtime.\n  isSignal: boolean;\n}\n\n/** Flags describing an input for a directive. */\nexport enum InputFlags {\n  None = 0,\n  SignalBased = 1 << 0,\n  HasDecoratorInputTransform = 1 << 1,\n}\n\nexport interface Output {\n  alias?: string;\n}\n\nexport interface HostBinding {\n  hostPropertyName?: string;\n}\n\nexport interface HostListener {\n  eventName?: string;\n  args?: string[];\n}\n\nexport interface SchemaMetadata {\n  name: string;\n}\n\nexport const CUSTOM_ELEMENTS_SCHEMA: SchemaMetadata = {\n  name: 'custom-elements',\n};\n\nexport const NO_ERRORS_SCHEMA: SchemaMetadata = {\n  name: 'no-errors-schema',\n};\n\nexport interface Type extends Function {\n  new (...args: any[]): any;\n}\nexport const Type = Function;\n\nexport enum SecurityContext {\n  NONE = 0,\n  HTML = 1,\n  STYLE = 2,\n  SCRIPT = 3,\n  URL = 4,\n  RESOURCE_URL = 5,\n}\n\n/**\n * Injection flags for DI.\n */\nexport const enum InjectFlags {\n  Default = 0,\n\n  /**\n   * Specifies that an injector should retrieve a dependency from any injector until reaching the\n   * host element of the current component. (Only used with Element Injector)\n   */\n  Host = 1 << 0,\n  /** Don't descend into ancestors of the node requesting injection. */\n  Self = 1 << 1,\n  /** Skip the node that is requesting injection. */\n  SkipSelf = 1 << 2,\n  /** Inject `defaultValue` instead if token not found. */\n  Optional = 1 << 3,\n  /**\n   * This token is being injected into a pipe.\n   * @internal\n   */\n  ForPipe = 1 << 4,\n}\n\nexport enum MissingTranslationStrategy {\n  Error = 0,\n  Warning = 1,\n  Ignore = 2,\n}\n\n/**\n * Flags used to generate R3-style CSS Selectors. They are pasted from\n * core/src/render3/projection.ts because they cannot be referenced directly.\n */\nexport const enum SelectorFlags {\n  /** Indicates this is the beginning of a new negative selector */\n  NOT = 0b0001,\n\n  /** Mode for matching attributes */\n  ATTRIBUTE = 0b0010,\n\n  /** Mode for matching tag names */\n  ELEMENT = 0b0100,\n\n  /** Mode for matching class names */\n  CLASS = 0b1000,\n}\n\n// These are a copy the CSS types from core/src/render3/interfaces/projection.ts\n// They are duplicated here as they cannot be directly referenced from core.\nexport type R3CssSelector = (string | SelectorFlags)[];\nexport type R3CssSelectorList = R3CssSelector[];\n\nfunction parserSelectorToSimpleSelector(selector: CssSelector): R3CssSelector {\n  const classes =\n    selector.classNames && selector.classNames.length\n      ? [SelectorFlags.CLASS, ...selector.classNames]\n      : [];\n  const elementName = selector.element && selector.element !== '*' ? selector.element : '';\n  return [elementName, ...selector.attrs, ...classes];\n}\n\nfunction parserSelectorToNegativeSelector(selector: CssSelector): R3CssSelector {\n  const classes =\n    selector.classNames && selector.classNames.length\n      ? [SelectorFlags.CLASS, ...selector.classNames]\n      : [];\n\n  if (selector.element) {\n    return [\n      SelectorFlags.NOT | SelectorFlags.ELEMENT,\n      selector.element,\n      ...selector.attrs,\n      ...classes,\n    ];\n  } else if (selector.attrs.length) {\n    return [SelectorFlags.NOT | SelectorFlags.ATTRIBUTE, ...selector.attrs, ...classes];\n  } else {\n    return selector.classNames && selector.classNames.length\n      ? [SelectorFlags.NOT | SelectorFlags.CLASS, ...selector.classNames]\n      : [];\n  }\n}\n\nfunction parserSelectorToR3Selector(selector: CssSelector): R3CssSelector {\n  const positive = parserSelectorToSimpleSelector(selector);\n\n  const negative: R3CssSelectorList =\n    selector.notSelectors && selector.notSelectors.length\n      ? selector.notSelectors.map((notSelector) => parserSelectorToNegativeSelector(notSelector))\n      : [];\n\n  return positive.concat(...negative);\n}\n\nexport function parseSelectorToR3Selector(selector: string | null): R3CssSelectorList {\n  return selector ? CssSelector.parse(selector).map(parserSelectorToR3Selector) : [];\n}\n\n// Pasted from render3/interfaces/definition since it cannot be referenced directly\n/**\n * Flags passed into template functions to determine which blocks (i.e. creation, update)\n * should be executed.\n *\n * Typically, a template runs both the creation block and the update block on initialization and\n * subsequent runs only execute the update block. However, dynamically created views require that\n * the creation block be executed separately from the update block (for backwards compat).\n */\nexport const enum RenderFlags {\n  /* Whether to run the creation block (e.g. create elements and directives) */\n  Create = 0b01,\n\n  /* Whether to run the update block (e.g. refresh bindings) */\n  Update = 0b10,\n}\n\n// Pasted from render3/interfaces/node.ts\n/**\n * A set of marker values to be used in the attributes arrays. These markers indicate that some\n * items are not regular attributes and the processing should be adapted accordingly.\n */\nexport const enum AttributeMarker {\n  /**\n   * Marker indicates that the following 3 values in the attributes array are:\n   * namespaceUri, attributeName, attributeValue\n   * in that order.\n   */\n  NamespaceURI = 0,\n\n  /**\n   * Signals class declaration.\n   *\n   * Each value following `Classes` designates a class name to include on the element.\n   * ## Example:\n   *\n   * Given:\n   * ```html\n   * <div class=\"foo bar baz\">...</div>\n   * ```\n   *\n   * the generated code is:\n   * ```ts\n   * var _c1 = [AttributeMarker.Classes, 'foo', 'bar', 'baz'];\n   * ```\n   */\n  Classes = 1,\n\n  /**\n   * Signals style declaration.\n   *\n   * Each pair of values following `Styles` designates a style name and value to include on the\n   * element.\n   * ## Example:\n   *\n   * Given:\n   * ```html\n   * <div style=\"width:100px; height:200px; color:red\">...</div>\n   * ```\n   *\n   * the generated code is:\n   * ```ts\n   * var _c1 = [AttributeMarker.Styles, 'width', '100px', 'height'. '200px', 'color', 'red'];\n   * ```\n   */\n  Styles = 2,\n\n  /**\n   * Signals that the following attribute names were extracted from input or output bindings.\n   *\n   * For example, given the following HTML:\n   *\n   * ```html\n   * <div moo=\"car\" [foo]=\"exp\" (bar)=\"doSth()\">\n   * ```\n   *\n   * the generated code is:\n   *\n   * ```ts\n   * var _c1 = ['moo', 'car', AttributeMarker.Bindings, 'foo', 'bar'];\n   * ```\n   */\n  Bindings = 3,\n\n  /**\n   * Signals that the following attribute names were hoisted from an inline-template declaration.\n   *\n   * For example, given the following HTML:\n   *\n   * ```html\n   * <div *ngFor=\"let value of values; trackBy:trackBy\" dirA [dirB]=\"value\">\n   * ```\n   *\n   * the generated code for the `template()` instruction would include:\n   *\n   * ```\n   * ['dirA', '', AttributeMarker.Bindings, 'dirB', AttributeMarker.Template, 'ngFor', 'ngForOf',\n   * 'ngForTrackBy', 'let-value']\n   * ```\n   *\n   * while the generated code for the `element()` instruction inside the template function would\n   * include:\n   *\n   * ```\n   * ['dirA', '', AttributeMarker.Bindings, 'dirB']\n   * ```\n   */\n  Template = 4,\n\n  /**\n   * Signals that the following attribute is `ngProjectAs` and its value is a parsed `CssSelector`.\n   *\n   * For example, given the following HTML:\n   *\n   * ```html\n   * <h1 attr=\"value\" ngProjectAs=\"[title]\">\n   * ```\n   *\n   * the generated code for the `element()` instruction would include:\n   *\n   * ```\n   * ['attr', 'value', AttributeMarker.ProjectAs, ['', 'title', '']]\n   * ```\n   */\n  ProjectAs = 5,\n\n  /**\n   * Signals that the following attribute will be translated by runtime i18n\n   *\n   * For example, given the following HTML:\n   *\n   * ```html\n   * <div moo=\"car\" foo=\"value\" i18n-foo [bar]=\"binding\" i18n-bar>\n   * ```\n   *\n   * the generated code is:\n   *\n   * ```ts\n   * var _c1 = ['moo', 'car', AttributeMarker.I18n, 'foo', 'bar'];\n   * ```\n   */\n  I18n = 6,\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Byte} from '../util';\n\nimport * as i18n from './i18n_ast';\n\n/**\n * A lazily created TextEncoder instance for converting strings into UTF-8 bytes\n */\nlet textEncoder: TextEncoder | undefined;\n\n/**\n * Return the message id or compute it using the XLIFF1 digest.\n */\nexport function digest(message: i18n.Message): string {\n  return message.id || computeDigest(message);\n}\n\n/**\n * Compute the message id using the XLIFF1 digest.\n */\nexport function computeDigest(message: i18n.Message): string {\n  return sha1(serializeNodes(message.nodes).join('') + `[${message.meaning}]`);\n}\n\n/**\n * Return the message id or compute it using the XLIFF2/XMB/$localize digest.\n */\nexport function decimalDigest(message: i18n.Message): string {\n  return message.id || computeDecimalDigest(message);\n}\n\n/**\n * Compute the message id using the XLIFF2/XMB/$localize digest.\n */\nexport function computeDecimalDigest(message: i18n.Message): string {\n  const visitor = new _SerializerIgnoreIcuExpVisitor();\n  const parts = message.nodes.map((a) => a.visit(visitor, null));\n  return computeMsgId(parts.join(''), message.meaning);\n}\n\n/**\n * Serialize the i18n ast to something xml-like in order to generate an UID.\n *\n * The visitor is also used in the i18n parser tests\n *\n * @internal\n */\nclass _SerializerVisitor implements i18n.Visitor {\n  visitText(text: i18n.Text, context: any): any {\n    return text.value;\n  }\n\n  visitContainer(container: i18n.Container, context: any): any {\n    return `[${container.children.map((child) => child.visit(this)).join(', ')}]`;\n  }\n\n  visitIcu(icu: i18n.Icu, context: any): any {\n    const strCases = Object.keys(icu.cases).map(\n      (k: string) => `${k} {${icu.cases[k].visit(this)}}`,\n    );\n    return `{${icu.expression}, ${icu.type}, ${strCases.join(', ')}}`;\n  }\n\n  visitTagPlaceholder(ph: i18n.TagPlaceholder, context: any): any {\n    return ph.isVoid\n      ? `<ph tag name=\"${ph.startName}\"/>`\n      : `<ph tag name=\"${ph.startName}\">${ph.children\n          .map((child) => child.visit(this))\n          .join(', ')}</ph name=\"${ph.closeName}\">`;\n  }\n\n  visitPlaceholder(ph: i18n.Placeholder, context: any): any {\n    return ph.value ? `<ph name=\"${ph.name}\">${ph.value}</ph>` : `<ph name=\"${ph.name}\"/>`;\n  }\n\n  visitIcuPlaceholder(ph: i18n.IcuPlaceholder, context?: any): any {\n    return `<ph icu name=\"${ph.name}\">${ph.value.visit(this)}</ph>`;\n  }\n\n  visitBlockPlaceholder(ph: i18n.BlockPlaceholder, context: any): any {\n    return `<ph block name=\"${ph.startName}\">${ph.children\n      .map((child) => child.visit(this))\n      .join(', ')}</ph name=\"${ph.closeName}\">`;\n  }\n}\n\nconst serializerVisitor = new _SerializerVisitor();\n\nexport function serializeNodes(nodes: i18n.Node[]): string[] {\n  return nodes.map((a) => a.visit(serializerVisitor, null));\n}\n\n/**\n * Serialize the i18n ast to something xml-like in order to generate an UID.\n *\n * Ignore the ICU expressions so that message IDs stays identical if only the expression changes.\n *\n * @internal\n */\nclass _SerializerIgnoreIcuExpVisitor extends _SerializerVisitor {\n  override visitIcu(icu: i18n.Icu): string {\n    let strCases = Object.keys(icu.cases).map((k: string) => `${k} {${icu.cases[k].visit(this)}}`);\n    // Do not take the expression into account\n    return `{${icu.type}, ${strCases.join(', ')}}`;\n  }\n}\n\n/**\n * Compute the SHA1 of the given string\n *\n * see https://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf\n *\n * WARNING: this function has not been designed not tested with security in mind.\n *          DO NOT USE IT IN A SECURITY SENSITIVE CONTEXT.\n */\nexport function sha1(str: string): string {\n  textEncoder ??= new TextEncoder();\n  const utf8 = [...textEncoder.encode(str)];\n  const words32 = bytesToWords32(utf8, Endian.Big);\n  const len = utf8.length * 8;\n\n  const w = new Uint32Array(80);\n  let a = 0x67452301,\n    b = 0xefcdab89,\n    c = 0x98badcfe,\n    d = 0x10325476,\n    e = 0xc3d2e1f0;\n\n  words32[len >> 5] |= 0x80 << (24 - (len % 32));\n  words32[(((len + 64) >> 9) << 4) + 15] = len;\n\n  for (let i = 0; i < words32.length; i += 16) {\n    const h0 = a,\n      h1 = b,\n      h2 = c,\n      h3 = d,\n      h4 = e;\n\n    for (let j = 0; j < 80; j++) {\n      if (j < 16) {\n        w[j] = words32[i + j];\n      } else {\n        w[j] = rol32(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);\n      }\n\n      const fkVal = fk(j, b, c, d);\n      const f = fkVal[0];\n      const k = fkVal[1];\n      const temp = [rol32(a, 5), f, e, k, w[j]].reduce(add32);\n      e = d;\n      d = c;\n      c = rol32(b, 30);\n      b = a;\n      a = temp;\n    }\n    a = add32(a, h0);\n    b = add32(b, h1);\n    c = add32(c, h2);\n    d = add32(d, h3);\n    e = add32(e, h4);\n  }\n\n  // Convert the output parts to a 160-bit hexadecimal string\n  return toHexU32(a) + toHexU32(b) + toHexU32(c) + toHexU32(d) + toHexU32(e);\n}\n\n/**\n * Convert and format a number as a string representing a 32-bit unsigned hexadecimal number.\n * @param value The value to format as a string.\n * @returns A hexadecimal string representing the value.\n */\nfunction toHexU32(value: number): string {\n  // unsigned right shift of zero ensures an unsigned 32-bit number\n  return (value >>> 0).toString(16).padStart(8, '0');\n}\n\nfunction fk(index: number, b: number, c: number, d: number): [number, number] {\n  if (index < 20) {\n    return [(b & c) | (~b & d), 0x5a827999];\n  }\n\n  if (index < 40) {\n    return [b ^ c ^ d, 0x6ed9eba1];\n  }\n\n  if (index < 60) {\n    return [(b & c) | (b & d) | (c & d), 0x8f1bbcdc];\n  }\n\n  return [b ^ c ^ d, 0xca62c1d6];\n}\n\n/**\n * Compute the fingerprint of the given string\n *\n * The output is 64 bit number encoded as a decimal string\n *\n * based on:\n * https://github.com/google/closure-compiler/blob/master/src/com/google/javascript/jscomp/GoogleJsMessageIdGenerator.java\n */\nexport function fingerprint(str: string): bigint {\n  textEncoder ??= new TextEncoder();\n  const utf8 = textEncoder.encode(str);\n  const view = new DataView(utf8.buffer, utf8.byteOffset, utf8.byteLength);\n\n  let hi = hash32(view, utf8.length, 0);\n  let lo = hash32(view, utf8.length, 102072);\n\n  if (hi == 0 && (lo == 0 || lo == 1)) {\n    hi = hi ^ 0x130f9bef;\n    lo = lo ^ -0x6b5f56d8;\n  }\n\n  return (BigInt.asUintN(32, BigInt(hi)) << BigInt(32)) | BigInt.asUintN(32, BigInt(lo));\n}\n\nexport function computeMsgId(msg: string, meaning: string = ''): string {\n  let msgFingerprint = fingerprint(msg);\n\n  if (meaning) {\n    // Rotate the 64-bit message fingerprint one bit to the left and then add the meaning\n    // fingerprint.\n    msgFingerprint =\n      BigInt.asUintN(64, msgFingerprint << BigInt(1)) |\n      ((msgFingerprint >> BigInt(63)) & BigInt(1));\n    msgFingerprint += fingerprint(meaning);\n  }\n\n  return BigInt.asUintN(63, msgFingerprint).toString();\n}\n\nfunction hash32(view: DataView, length: number, c: number): number {\n  let a = 0x9e3779b9,\n    b = 0x9e3779b9;\n  let index = 0;\n\n  const end = length - 12;\n  for (; index <= end; index += 12) {\n    a += view.getUint32(index, true);\n    b += view.getUint32(index + 4, true);\n    c += view.getUint32(index + 8, true);\n    const res = mix(a, b, c);\n    (a = res[0]), (b = res[1]), (c = res[2]);\n  }\n\n  const remainder = length - index;\n\n  // the first byte of c is reserved for the length\n  c += length;\n\n  if (remainder >= 4) {\n    a += view.getUint32(index, true);\n    index += 4;\n\n    if (remainder >= 8) {\n      b += view.getUint32(index, true);\n      index += 4;\n\n      // Partial 32-bit word for c\n      if (remainder >= 9) {\n        c += view.getUint8(index++) << 8;\n      }\n      if (remainder >= 10) {\n        c += view.getUint8(index++) << 16;\n      }\n      if (remainder === 11) {\n        c += view.getUint8(index++) << 24;\n      }\n    } else {\n      // Partial 32-bit word for b\n      if (remainder >= 5) {\n        b += view.getUint8(index++);\n      }\n      if (remainder >= 6) {\n        b += view.getUint8(index++) << 8;\n      }\n      if (remainder === 7) {\n        b += view.getUint8(index++) << 16;\n      }\n    }\n  } else {\n    // Partial 32-bit word for a\n    if (remainder >= 1) {\n      a += view.getUint8(index++);\n    }\n    if (remainder >= 2) {\n      a += view.getUint8(index++) << 8;\n    }\n    if (remainder === 3) {\n      a += view.getUint8(index++) << 16;\n    }\n  }\n\n  return mix(a, b, c)[2];\n}\n\nfunction mix(a: number, b: number, c: number): [number, number, number] {\n  a -= b;\n  a -= c;\n  a ^= c >>> 13;\n  b -= c;\n  b -= a;\n  b ^= a << 8;\n  c -= a;\n  c -= b;\n  c ^= b >>> 13;\n  a -= b;\n  a -= c;\n  a ^= c >>> 12;\n  b -= c;\n  b -= a;\n  b ^= a << 16;\n  c -= a;\n  c -= b;\n  c ^= b >>> 5;\n  a -= b;\n  a -= c;\n  a ^= c >>> 3;\n  b -= c;\n  b -= a;\n  b ^= a << 10;\n  c -= a;\n  c -= b;\n  c ^= b >>> 15;\n  return [a, b, c];\n}\n\n// Utils\n\nenum Endian {\n  Little,\n  Big,\n}\n\nfunction add32(a: number, b: number): number {\n  return add32to64(a, b)[1];\n}\n\nfunction add32to64(a: number, b: number): [number, number] {\n  const low = (a & 0xffff) + (b & 0xffff);\n  const high = (a >>> 16) + (b >>> 16) + (low >>> 16);\n  return [high >>> 16, (high << 16) | (low & 0xffff)];\n}\n\n// Rotate a 32b number left `count` position\nfunction rol32(a: number, count: number): number {\n  return (a << count) | (a >>> (32 - count));\n}\n\nfunction bytesToWords32(bytes: Byte[], endian: Endian): number[] {\n  const size = (bytes.length + 3) >>> 2;\n  const words32 = [];\n\n  for (let i = 0; i < size; i++) {\n    words32[i] = wordAt(bytes, i * 4, endian);\n  }\n\n  return words32;\n}\n\nfunction byteAt(bytes: Byte[], index: number): Byte {\n  return index >= bytes.length ? 0 : bytes[index];\n}\n\nfunction wordAt(bytes: Byte[], index: number, endian: Endian): number {\n  let word = 0;\n  if (endian === Endian.Big) {\n    for (let i = 0; i < 4; i++) {\n      word += byteAt(bytes, index + i) << (24 - 8 * i);\n    }\n  } else {\n    for (let i = 0; i < 4; i++) {\n      word += byteAt(bytes, index + i) << (8 * i);\n    }\n  }\n  return word;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computeMsgId} from '../i18n/digest';\nimport {Message} from '../i18n/i18n_ast';\nimport {ParseSourceSpan} from '../parse_util';\nimport type {I18nMeta} from '../render3/view/i18n/meta';\n\n//// Types\nexport enum TypeModifier {\n  None = 0,\n  Const = 1 << 0,\n}\n\nexport abstract class Type {\n  constructor(public modifiers: TypeModifier = TypeModifier.None) {}\n  abstract visitType(visitor: TypeVisitor, context: any): any;\n\n  hasModifier(modifier: TypeModifier): boolean {\n    return (this.modifiers & modifier) !== 0;\n  }\n}\n\nexport enum BuiltinTypeName {\n  Dynamic,\n  Bool,\n  String,\n  Int,\n  Number,\n  Function,\n  Inferred,\n  None,\n}\n\nexport class BuiltinType extends Type {\n  constructor(\n    public name: BuiltinTypeName,\n    modifiers?: TypeModifier,\n  ) {\n    super(modifiers);\n  }\n  override visitType(visitor: TypeVisitor, context: any): any {\n    return visitor.visitBuiltinType(this, context);\n  }\n}\n\nexport class ExpressionType extends Type {\n  constructor(\n    public value: Expression,\n    modifiers?: TypeModifier,\n    public typeParams: Type[] | null = null,\n  ) {\n    super(modifiers);\n  }\n  override visitType(visitor: TypeVisitor, context: any): any {\n    return visitor.visitExpressionType(this, context);\n  }\n}\n\nexport class ArrayType extends Type {\n  constructor(\n    public of: Type,\n    modifiers?: TypeModifier,\n  ) {\n    super(modifiers);\n  }\n  override visitType(visitor: TypeVisitor, context: any): any {\n    return visitor.visitArrayType(this, context);\n  }\n}\n\nexport class MapType extends Type {\n  public valueType: Type | null;\n  constructor(valueType: Type | null | undefined, modifiers?: TypeModifier) {\n    super(modifiers);\n    this.valueType = valueType || null;\n  }\n  override visitType(visitor: TypeVisitor, context: any): any {\n    return visitor.visitMapType(this, context);\n  }\n}\n\nexport class TransplantedType<T> extends Type {\n  constructor(\n    readonly type: T,\n    modifiers?: TypeModifier,\n  ) {\n    super(modifiers);\n  }\n  override visitType(visitor: TypeVisitor, context: any): any {\n    return visitor.visitTransplantedType(this, context);\n  }\n}\n\nexport const DYNAMIC_TYPE = new BuiltinType(BuiltinTypeName.Dynamic);\nexport const INFERRED_TYPE = new BuiltinType(BuiltinTypeName.Inferred);\nexport const BOOL_TYPE = new BuiltinType(BuiltinTypeName.Bool);\nexport const INT_TYPE = new BuiltinType(BuiltinTypeName.Int);\nexport const NUMBER_TYPE = new BuiltinType(BuiltinTypeName.Number);\nexport const STRING_TYPE = new BuiltinType(BuiltinTypeName.String);\nexport const FUNCTION_TYPE = new BuiltinType(BuiltinTypeName.Function);\nexport const NONE_TYPE = new BuiltinType(BuiltinTypeName.None);\n\nexport interface TypeVisitor {\n  visitBuiltinType(type: BuiltinType, context: any): any;\n  visitExpressionType(type: ExpressionType, context: any): any;\n  visitArrayType(type: ArrayType, context: any): any;\n  visitMapType(type: MapType, context: any): any;\n  visitTransplantedType(type: TransplantedType<unknown>, context: any): any;\n}\n\n///// Expressions\n\nexport enum UnaryOperator {\n  Minus,\n  Plus,\n}\n\nexport enum BinaryOperator {\n  Equals,\n  NotEquals,\n  Identical,\n  NotIdentical,\n  Minus,\n  Plus,\n  Divide,\n  Multiply,\n  Modulo,\n  And,\n  Or,\n  BitwiseOr,\n  BitwiseAnd,\n  Lower,\n  LowerEquals,\n  Bigger,\n  BiggerEquals,\n  NullishCoalesce,\n}\n\nexport function nullSafeIsEquivalent<T extends {isEquivalent(other: T): boolean}>(\n  base: T | null,\n  other: T | null,\n) {\n  if (base == null || other == null) {\n    return base == other;\n  }\n  return base.isEquivalent(other);\n}\n\nfunction areAllEquivalentPredicate<T>(\n  base: T[],\n  other: T[],\n  equivalentPredicate: (baseElement: T, otherElement: T) => boolean,\n) {\n  const len = base.length;\n  if (len !== other.length) {\n    return false;\n  }\n  for (let i = 0; i < len; i++) {\n    if (!equivalentPredicate(base[i], other[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function areAllEquivalent<T extends {isEquivalent(other: T): boolean}>(\n  base: T[],\n  other: T[],\n) {\n  return areAllEquivalentPredicate(base, other, (baseElement: T, otherElement: T) =>\n    baseElement.isEquivalent(otherElement),\n  );\n}\n\nexport abstract class Expression {\n  public type: Type | null;\n  public sourceSpan: ParseSourceSpan | null;\n\n  constructor(type: Type | null | undefined, sourceSpan?: ParseSourceSpan | null) {\n    this.type = type || null;\n    this.sourceSpan = sourceSpan || null;\n  }\n\n  abstract visitExpression(visitor: ExpressionVisitor, context: any): any;\n\n  /**\n   * Calculates whether this expression produces the same value as the given expression.\n   * Note: We don't check Types nor ParseSourceSpans nor function arguments.\n   */\n  abstract isEquivalent(e: Expression): boolean;\n\n  /**\n   * Return true if the expression is constant.\n   */\n  abstract isConstant(): boolean;\n\n  abstract clone(): Expression;\n\n  prop(name: string, sourceSpan?: ParseSourceSpan | null): ReadPropExpr {\n    return new ReadPropExpr(this, name, null, sourceSpan);\n  }\n\n  key(index: Expression, type?: Type | null, sourceSpan?: ParseSourceSpan | null): ReadKeyExpr {\n    return new ReadKeyExpr(this, index, type, sourceSpan);\n  }\n\n  callFn(\n    params: Expression[],\n    sourceSpan?: ParseSourceSpan | null,\n    pure?: boolean,\n  ): InvokeFunctionExpr {\n    return new InvokeFunctionExpr(this, params, null, sourceSpan, pure);\n  }\n\n  instantiate(\n    params: Expression[],\n    type?: Type | null,\n    sourceSpan?: ParseSourceSpan | null,\n  ): InstantiateExpr {\n    return new InstantiateExpr(this, params, type, sourceSpan);\n  }\n\n  conditional(\n    trueCase: Expression,\n    falseCase: Expression | null = null,\n    sourceSpan?: ParseSourceSpan | null,\n  ): ConditionalExpr {\n    return new ConditionalExpr(this, trueCase, falseCase, null, sourceSpan);\n  }\n\n  equals(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Equals, this, rhs, null, sourceSpan);\n  }\n  notEquals(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.NotEquals, this, rhs, null, sourceSpan);\n  }\n  identical(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Identical, this, rhs, null, sourceSpan);\n  }\n  notIdentical(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.NotIdentical, this, rhs, null, sourceSpan);\n  }\n  minus(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Minus, this, rhs, null, sourceSpan);\n  }\n  plus(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Plus, this, rhs, null, sourceSpan);\n  }\n  divide(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Divide, this, rhs, null, sourceSpan);\n  }\n  multiply(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Multiply, this, rhs, null, sourceSpan);\n  }\n  modulo(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Modulo, this, rhs, null, sourceSpan);\n  }\n  and(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.And, this, rhs, null, sourceSpan);\n  }\n  bitwiseOr(\n    rhs: Expression,\n    sourceSpan?: ParseSourceSpan | null,\n    parens: boolean = true,\n  ): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.BitwiseOr, this, rhs, null, sourceSpan, parens);\n  }\n  bitwiseAnd(\n    rhs: Expression,\n    sourceSpan?: ParseSourceSpan | null,\n    parens: boolean = true,\n  ): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.BitwiseAnd, this, rhs, null, sourceSpan, parens);\n  }\n  or(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Or, this, rhs, null, sourceSpan);\n  }\n  lower(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Lower, this, rhs, null, sourceSpan);\n  }\n  lowerEquals(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.LowerEquals, this, rhs, null, sourceSpan);\n  }\n  bigger(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Bigger, this, rhs, null, sourceSpan);\n  }\n  biggerEquals(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.BiggerEquals, this, rhs, null, sourceSpan);\n  }\n  isBlank(sourceSpan?: ParseSourceSpan | null): Expression {\n    // Note: We use equals by purpose here to compare to null and undefined in JS.\n    // We use the typed null to allow strictNullChecks to narrow types.\n    return this.equals(TYPED_NULL_EXPR, sourceSpan);\n  }\n  nullishCoalesce(rhs: Expression, sourceSpan?: ParseSourceSpan | null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.NullishCoalesce, this, rhs, null, sourceSpan);\n  }\n\n  toStmt(): Statement {\n    return new ExpressionStatement(this, null);\n  }\n}\n\nexport class ReadVarExpr extends Expression {\n  constructor(\n    public name: string,\n    type?: Type | null,\n    sourceSpan?: ParseSourceSpan | null,\n  ) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof ReadVarExpr && this.name === e.name;\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitReadVarExpr(this, context);\n  }\n\n  override clone(): ReadVarExpr {\n    return new ReadVarExpr(this.name, this.type, this.sourceSpan);\n  }\n\n  set(value: Expression): WriteVarExpr {\n    return new WriteVarExpr(this.name, value, null, this.sourceSpan);\n  }\n}\n\nexport class TypeofExpr extends Expression {\n  constructor(\n    public expr: Expression,\n    type?: Type | null,\n    sourceSpan?: ParseSourceSpan | null,\n  ) {\n    super(type, sourceSpan);\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any) {\n    return visitor.visitTypeofExpr(this, context);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof TypeofExpr && e.expr.isEquivalent(this.expr);\n  }\n\n  override isConstant(): boolean {\n    return this.expr.isConstant();\n  }\n\n  override clone(): TypeofExpr {\n    return new TypeofExpr(this.expr.clone());\n  }\n}\n\nexport class WrappedNodeExpr<T> extends Expression {\n  constructor(\n    public node: T,\n    type?: Type | null,\n    sourceSpan?: ParseSourceSpan | null,\n  ) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof WrappedNodeExpr && this.node === e.node;\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitWrappedNodeExpr(this, context);\n  }\n\n  override clone(): WrappedNodeExpr<T> {\n    return new WrappedNodeExpr(this.node, this.type, this.sourceSpan);\n  }\n}\n\nexport class WriteVarExpr extends Expression {\n  public value: Expression;\n  constructor(\n    public name: string,\n    value: Expression,\n    type?: Type | null,\n    sourceSpan?: ParseSourceSpan | null,\n  ) {\n    super(type || value.type, sourceSpan);\n    this.value = value;\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof WriteVarExpr && this.name === e.name && this.value.isEquivalent(e.value);\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitWriteVarExpr(this, context);\n  }\n\n  override clone(): WriteVarExpr {\n    return new WriteVarExpr(this.name, this.value.clone(), this.type, this.sourceSpan);\n  }\n\n  toDeclStmt(type?: Type | null, modifiers?: StmtModifier): DeclareVarStmt {\n    return new DeclareVarStmt(this.name, this.value, type, modifiers, this.sourceSpan);\n  }\n\n  toConstDecl(): DeclareVarStmt {\n    return this.toDeclStmt(INFERRED_TYPE, StmtModifier.Final);\n  }\n}\n\nexport class WriteKeyExpr extends Expression {\n  public value: Expression;\n  constructor(\n    public receiver: Expression,\n    public index: Expression,\n    value: Expression,\n    type?: Type | null,\n    sourceSpan?: ParseSourceSpan | null,\n  ) {\n    super(type || value.type, sourceSpan);\n    this.value = value;\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return (\n      e instanceof WriteKeyExpr &&\n      this.receiver.isEquivalent(e.receiver) &&\n      this.index.isEquivalent(e.index) &&\n      this.value.isEquivalent(e.value)\n    );\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitWriteKeyExpr(this, context);\n  }\n\n  override clone(): WriteKeyExpr {\n    return new WriteKeyExpr(\n      this.receiver.clone(),\n      this.index.clone(),\n      this.value.clone(),\n      this.type,\n      this.sourceSpan,\n    );\n  }\n}\n\nexport class WritePropExpr extends Expression {\n  public value: Expression;\n  constructor(\n    public receiver: Expression,\n    public name: string,\n    value: Expression,\n    type?: Type | null,\n    sourceSpan?: ParseSourceSpan | null,\n  ) {\n    super(type || value.type, sourceSpan);\n    this.value = value;\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return (\n      e instanceof WritePropExpr &&\n      this.receiver.isEquivalent(e.receiver) &&\n      this.name === e.name &&\n      this.value.isEquivalent(e.value)\n    );\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitWritePropExpr(this, context);\n  }\n\n  override clone(): WritePropExpr {\n    return new WritePropExpr(\n      this.receiver.clone(),\n      this.name,\n      this.value.clone(),\n      this.type,\n      this.sourceSpan,\n    );\n  }\n}\n\nexport class InvokeFunctionExpr extends Expression {\n  constructor(\n    public fn: Expression,\n    public args: Expression[],\n    type?: Type | null,\n    sourceSpan?: ParseSourceSpan | null,\n    public pure = false,\n  ) {\n    super(type, sourceSpan);\n  }\n\n  // An alias for fn, which allows other logic to handle calls and property reads together.\n  get receiver(): Expression {\n    return this.fn;\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return (\n      e instanceof InvokeFunctionExpr &&\n      this.fn.isEquivalent(e.fn) &&\n      areAllEquivalent(this.args, e.args) &&\n      this.pure === e.pure\n    );\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitInvokeFunctionExpr(this, context);\n  }\n\n  override clone(): InvokeFunctionExpr {\n    return new InvokeFunctionExpr(\n      this.fn.clone(),\n      this.args.map((arg) => arg.clone()),\n      this.type,\n      this.sourceSpan,\n      this.pure,\n    );\n  }\n}\n\nexport class TaggedTemplateLiteralExpr extends Expression {\n  constructor(\n    public tag: Expression,\n    public template: TemplateLiteralExpr,\n    type?: Type | null,\n    sourceSpan?: ParseSourceSpan | null,\n  ) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return (\n      e instanceof TaggedTemplateLiteralExpr &&\n      this.tag.isEquivalent(e.tag) &&\n      this.template.isEquivalent(e.template)\n    );\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitTaggedTemplateLiteralExpr(this, context);\n  }\n\n  override clone(): TaggedTemplateLiteralExpr {\n    return new TaggedTemplateLiteralExpr(\n      this.tag.clone(),\n      this.template.clone(),\n      this.type,\n      this.sourceSpan,\n    );\n  }\n}\n\nexport class InstantiateExpr extends Expression {\n  constructor(\n    public classExpr: Expression,\n    public args: Expression[],\n    type?: Type | null,\n    sourceSpan?: ParseSourceSpan | null,\n  ) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return (\n      e instanceof InstantiateExpr &&\n      this.classExpr.isEquivalent(e.classExpr) &&\n      areAllEquivalent(this.args, e.args)\n    );\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitInstantiateExpr(this, context);\n  }\n\n  override clone(): InstantiateExpr {\n    return new InstantiateExpr(\n      this.classExpr.clone(),\n      this.args.map((arg) => arg.clone()),\n      this.type,\n      this.sourceSpan,\n    );\n  }\n}\n\nexport class LiteralExpr extends Expression {\n  constructor(\n    public value: number | string | boolean | null | undefined,\n    type?: Type | null,\n    sourceSpan?: ParseSourceSpan | null,\n  ) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof LiteralExpr && this.value === e.value;\n  }\n\n  override isConstant() {\n    return true;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitLiteralExpr(this, context);\n  }\n\n  override clone(): LiteralExpr {\n    return new LiteralExpr(this.value, this.type, this.sourceSpan);\n  }\n}\n\nexport class TemplateLiteralExpr extends Expression {\n  constructor(\n    public elements: TemplateLiteralElementExpr[],\n    public expressions: Expression[],\n    sourceSpan?: ParseSourceSpan | null,\n  ) {\n    super(null, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return (\n      e instanceof TemplateLiteralExpr &&\n      areAllEquivalentPredicate(this.elements, e.elements, (a, b) => a.text === b.text) &&\n      areAllEquivalent(this.expressions, e.expressions)\n    );\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitTemplateLiteralExpr(this, context);\n  }\n\n  override clone(): TemplateLiteralExpr {\n    return new TemplateLiteralExpr(\n      this.elements.map((el) => el.clone()),\n      this.expressions.map((expr) => expr.clone()),\n    );\n  }\n}\nexport class TemplateLiteralElementExpr extends Expression {\n  readonly rawText: string;\n\n  constructor(\n    readonly text: string,\n    sourceSpan?: ParseSourceSpan | null,\n    rawText?: string,\n  ) {\n    super(STRING_TYPE, sourceSpan);\n\n    // If `rawText` is not provided, \"fake\" the raw string by escaping the following sequences:\n    // - \"\\\" would otherwise indicate that the next character is a control character.\n    // - \"`\" and \"${\" are template string control sequences that would otherwise prematurely\n    // indicate the end of the template literal element.\n    // Note that we can't rely on the `sourceSpan` here, because it may be incorrect (see\n    // https://github.com/angular/angular/pull/60267#discussion_r1986402524).\n    this.rawText = rawText ?? escapeForTemplateLiteral(escapeSlashes(text));\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any) {\n    return visitor.visitTemplateLiteralElementExpr(this, context);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return (\n      e instanceof TemplateLiteralElementExpr && e.text === this.text && e.rawText === this.rawText\n    );\n  }\n\n  override isConstant(): boolean {\n    return true;\n  }\n\n  override clone(): TemplateLiteralElementExpr {\n    return new TemplateLiteralElementExpr(this.text, this.sourceSpan, this.rawText);\n  }\n}\n\nexport class LiteralPiece {\n  constructor(\n    public text: string,\n    public sourceSpan: ParseSourceSpan,\n  ) {}\n}\nexport class PlaceholderPiece {\n  /**\n   * Create a new instance of a `PlaceholderPiece`.\n   *\n   * @param text the name of this placeholder (e.g. `PH_1`).\n   * @param sourceSpan the location of this placeholder in its localized message the source code.\n   * @param associatedMessage reference to another message that this placeholder is associated with.\n   * The `associatedMessage` is mainly used to provide a relationship to an ICU message that has\n   * been extracted out from the message containing the placeholder.\n   */\n  constructor(\n    public text: string,\n    public sourceSpan: ParseSourceSpan,\n    public associatedMessage?: Message,\n  ) {}\n}\n\nexport type MessagePiece = LiteralPiece | PlaceholderPiece;\n\nconst MEANING_SEPARATOR = '|';\nconst ID_SEPARATOR = '@@';\nconst LEGACY_ID_INDICATOR = '';\n\nexport class LocalizedString extends Expression {\n  constructor(\n    readonly metaBlock: I18nMeta,\n    readonly messageParts: LiteralPiece[],\n    readonly placeHolderNames: PlaceholderPiece[],\n    readonly expressions: Expression[],\n    sourceSpan?: ParseSourceSpan | null,\n  ) {\n    super(STRING_TYPE, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    // return e instanceof LocalizedString && this.message === e.message;\n    return false;\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitLocalizedString(this, context);\n  }\n\n  override clone(): LocalizedString {\n    return new LocalizedString(\n      this.metaBlock,\n      this.messageParts,\n      this.placeHolderNames,\n      this.expressions.map((expr) => expr.clone()),\n      this.sourceSpan,\n    );\n  }\n\n  /**\n   * Serialize the given `meta` and `messagePart` into \"cooked\" and \"raw\" strings that can be used\n   * in a `$localize` tagged string. The format of the metadata is the same as that parsed by\n   * `parseI18nMeta()`.\n   *\n   * @param meta The metadata to serialize\n   * @param messagePart The first part of the tagged string\n   */\n  serializeI18nHead(): CookedRawString {\n    let metaBlock = this.metaBlock.description || '';\n    if (this.metaBlock.meaning) {\n      metaBlock = `${this.metaBlock.meaning}${MEANING_SEPARATOR}${metaBlock}`;\n    }\n    if (this.metaBlock.customId) {\n      metaBlock = `${metaBlock}${ID_SEPARATOR}${this.metaBlock.customId}`;\n    }\n    if (this.metaBlock.legacyIds) {\n      this.metaBlock.legacyIds.forEach((legacyId) => {\n        metaBlock = `${metaBlock}${LEGACY_ID_INDICATOR}${legacyId}`;\n      });\n    }\n    return createCookedRawString(\n      metaBlock,\n      this.messageParts[0].text,\n      this.getMessagePartSourceSpan(0),\n    );\n  }\n\n  getMessagePartSourceSpan(i: number): ParseSourceSpan | null {\n    return this.messageParts[i]?.sourceSpan ?? this.sourceSpan;\n  }\n\n  getPlaceholderSourceSpan(i: number): ParseSourceSpan {\n    return (\n      this.placeHolderNames[i]?.sourceSpan ?? this.expressions[i]?.sourceSpan ?? this.sourceSpan\n    );\n  }\n\n  /**\n   * Serialize the given `placeholderName` and `messagePart` into \"cooked\" and \"raw\" strings that\n   * can be used in a `$localize` tagged string.\n   *\n   * The format is `:<placeholder-name>[@@<associated-id>]:`.\n   *\n   * The `associated-id` is the message id of the (usually an ICU) message to which this placeholder\n   * refers.\n   *\n   * @param partIndex The index of the message part to serialize.\n   */\n  serializeI18nTemplatePart(partIndex: number): CookedRawString {\n    const placeholder = this.placeHolderNames[partIndex - 1];\n    const messagePart = this.messageParts[partIndex];\n    let metaBlock = placeholder.text;\n    if (placeholder.associatedMessage?.legacyIds.length === 0) {\n      metaBlock += `${ID_SEPARATOR}${computeMsgId(\n        placeholder.associatedMessage.messageString,\n        placeholder.associatedMessage.meaning,\n      )}`;\n    }\n    return createCookedRawString(\n      metaBlock,\n      messagePart.text,\n      this.getMessagePartSourceSpan(partIndex),\n    );\n  }\n}\n\n/**\n * A structure to hold the cooked and raw strings of a template literal element, along with its\n * source-span range.\n */\nexport interface CookedRawString {\n  cooked: string;\n  raw: string;\n  range: ParseSourceSpan | null;\n}\n\nconst escapeSlashes = (str: string): string => str.replace(/\\\\/g, '\\\\\\\\');\nconst escapeStartingColon = (str: string): string => str.replace(/^:/, '\\\\:');\nconst escapeColons = (str: string): string => str.replace(/:/g, '\\\\:');\nconst escapeForTemplateLiteral = (str: string): string =>\n  str.replace(/`/g, '\\\\`').replace(/\\${/g, '$\\\\{');\n\n/**\n * Creates a `{cooked, raw}` object from the `metaBlock` and `messagePart`.\n *\n * The `raw` text must have various character sequences escaped:\n * * \"\\\" would otherwise indicate that the next character is a control character.\n * * \"`\" and \"${\" are template string control sequences that would otherwise prematurely indicate\n *   the end of a message part.\n * * \":\" inside a metablock would prematurely indicate the end of the metablock.\n * * \":\" at the start of a messagePart with no metablock would erroneously indicate the start of a\n *   metablock.\n *\n * @param metaBlock Any metadata that should be prepended to the string\n * @param messagePart The message part of the string\n */\nfunction createCookedRawString(\n  metaBlock: string,\n  messagePart: string,\n  range: ParseSourceSpan | null,\n): CookedRawString {\n  if (metaBlock === '') {\n    return {\n      cooked: messagePart,\n      raw: escapeForTemplateLiteral(escapeStartingColon(escapeSlashes(messagePart))),\n      range,\n    };\n  } else {\n    return {\n      cooked: `:${metaBlock}:${messagePart}`,\n      raw: escapeForTemplateLiteral(\n        `:${escapeColons(escapeSlashes(metaBlock))}:${escapeSlashes(messagePart)}`,\n      ),\n      range,\n    };\n  }\n}\n\nexport class ExternalExpr extends Expression {\n  constructor(\n    public value: ExternalReference,\n    type?: Type | null,\n    public typeParams: Type[] | null = null,\n    sourceSpan?: ParseSourceSpan | null,\n  ) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return (\n      e instanceof ExternalExpr &&\n      this.value.name === e.value.name &&\n      this.value.moduleName === e.value.moduleName\n    );\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitExternalExpr(this, context);\n  }\n\n  override clone(): ExternalExpr {\n    return new ExternalExpr(this.value, this.type, this.typeParams, this.sourceSpan);\n  }\n}\n\nexport class ExternalReference {\n  constructor(\n    public moduleName: string | null,\n    public name: string | null,\n  ) {}\n  // Note: no isEquivalent method here as we use this as an interface too.\n}\n\nexport class ConditionalExpr extends Expression {\n  public trueCase: Expression;\n\n  constructor(\n    public condition: Expression,\n    trueCase: Expression,\n    public falseCase: Expression | null = null,\n    type?: Type | null,\n    sourceSpan?: ParseSourceSpan | null,\n  ) {\n    super(type || trueCase.type, sourceSpan);\n    this.trueCase = trueCase;\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return (\n      e instanceof ConditionalExpr &&\n      this.condition.isEquivalent(e.condition) &&\n      this.trueCase.isEquivalent(e.trueCase) &&\n      nullSafeIsEquivalent(this.falseCase, e.falseCase)\n    );\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitConditionalExpr(this, context);\n  }\n\n  override clone(): ConditionalExpr {\n    return new ConditionalExpr(\n      this.condition.clone(),\n      this.trueCase.clone(),\n      this.falseCase?.clone(),\n      this.type,\n      this.sourceSpan,\n    );\n  }\n}\n\nexport class DynamicImportExpr extends Expression {\n  constructor(\n    public url: string | Expression,\n    sourceSpan?: ParseSourceSpan | null,\n    public urlComment?: string,\n  ) {\n    super(null, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof DynamicImportExpr && this.url === e.url && this.urlComment === e.urlComment;\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitDynamicImportExpr(this, context);\n  }\n\n  override clone(): DynamicImportExpr {\n    return new DynamicImportExpr(\n      typeof this.url === 'string' ? this.url : this.url.clone(),\n      this.sourceSpan,\n      this.urlComment,\n    );\n  }\n}\n\nexport class NotExpr extends Expression {\n  constructor(\n    public condition: Expression,\n    sourceSpan?: ParseSourceSpan | null,\n  ) {\n    super(BOOL_TYPE, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof NotExpr && this.condition.isEquivalent(e.condition);\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitNotExpr(this, context);\n  }\n\n  override clone(): NotExpr {\n    return new NotExpr(this.condition.clone(), this.sourceSpan);\n  }\n}\n\nexport class FnParam {\n  constructor(\n    public name: string,\n    public type: Type | null = null,\n  ) {}\n\n  isEquivalent(param: FnParam): boolean {\n    return this.name === param.name;\n  }\n\n  clone(): FnParam {\n    return new FnParam(this.name, this.type);\n  }\n}\n\nexport class FunctionExpr extends Expression {\n  constructor(\n    public params: FnParam[],\n    public statements: Statement[],\n    type?: Type | null,\n    sourceSpan?: ParseSourceSpan | null,\n    public name?: string | null,\n  ) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression | Statement): boolean {\n    return (\n      (e instanceof FunctionExpr || e instanceof DeclareFunctionStmt) &&\n      areAllEquivalent(this.params, e.params) &&\n      areAllEquivalent(this.statements, e.statements)\n    );\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitFunctionExpr(this, context);\n  }\n\n  toDeclStmt(name: string, modifiers?: StmtModifier): DeclareFunctionStmt {\n    return new DeclareFunctionStmt(\n      name,\n      this.params,\n      this.statements,\n      this.type,\n      modifiers,\n      this.sourceSpan,\n    );\n  }\n\n  override clone(): FunctionExpr {\n    // TODO: Should we deep clone statements?\n    return new FunctionExpr(\n      this.params.map((p) => p.clone()),\n      this.statements,\n      this.type,\n      this.sourceSpan,\n      this.name,\n    );\n  }\n}\n\nexport class ArrowFunctionExpr extends Expression {\n  // Note that `body: Expression` represents `() => expr` whereas\n  // `body: Statement[]` represents `() => { expr }`.\n\n  constructor(\n    public params: FnParam[],\n    public body: Expression | Statement[],\n    type?: Type | null,\n    sourceSpan?: ParseSourceSpan | null,\n  ) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    if (!(e instanceof ArrowFunctionExpr) || !areAllEquivalent(this.params, e.params)) {\n      return false;\n    }\n\n    if (this.body instanceof Expression && e.body instanceof Expression) {\n      return this.body.isEquivalent(e.body);\n    }\n\n    if (Array.isArray(this.body) && Array.isArray(e.body)) {\n      return areAllEquivalent(this.body, e.body);\n    }\n\n    return false;\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any) {\n    return visitor.visitArrowFunctionExpr(this, context);\n  }\n\n  override clone(): Expression {\n    // TODO: Should we deep clone statements?\n    return new ArrowFunctionExpr(\n      this.params.map((p) => p.clone()),\n      Array.isArray(this.body) ? this.body : this.body.clone(),\n      this.type,\n      this.sourceSpan,\n    );\n  }\n\n  toDeclStmt(name: string, modifiers?: StmtModifier): DeclareVarStmt {\n    return new DeclareVarStmt(name, this, INFERRED_TYPE, modifiers, this.sourceSpan);\n  }\n}\n\nexport class UnaryOperatorExpr extends Expression {\n  constructor(\n    public operator: UnaryOperator,\n    public expr: Expression,\n    type?: Type | null,\n    sourceSpan?: ParseSourceSpan | null,\n    public parens: boolean = true,\n  ) {\n    super(type || NUMBER_TYPE, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return (\n      e instanceof UnaryOperatorExpr &&\n      this.operator === e.operator &&\n      this.expr.isEquivalent(e.expr)\n    );\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitUnaryOperatorExpr(this, context);\n  }\n\n  override clone(): UnaryOperatorExpr {\n    return new UnaryOperatorExpr(\n      this.operator,\n      this.expr.clone(),\n      this.type,\n      this.sourceSpan,\n      this.parens,\n    );\n  }\n}\n\nexport class BinaryOperatorExpr extends Expression {\n  public lhs: Expression;\n  constructor(\n    public operator: BinaryOperator,\n    lhs: Expression,\n    public rhs: Expression,\n    type?: Type | null,\n    sourceSpan?: ParseSourceSpan | null,\n    public parens: boolean = true,\n  ) {\n    super(type || lhs.type, sourceSpan);\n    this.lhs = lhs;\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return (\n      e instanceof BinaryOperatorExpr &&\n      this.operator === e.operator &&\n      this.lhs.isEquivalent(e.lhs) &&\n      this.rhs.isEquivalent(e.rhs)\n    );\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitBinaryOperatorExpr(this, context);\n  }\n\n  override clone(): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(\n      this.operator,\n      this.lhs.clone(),\n      this.rhs.clone(),\n      this.type,\n      this.sourceSpan,\n      this.parens,\n    );\n  }\n}\n\nexport class ReadPropExpr extends Expression {\n  constructor(\n    public receiver: Expression,\n    public name: string,\n    type?: Type | null,\n    sourceSpan?: ParseSourceSpan | null,\n  ) {\n    super(type, sourceSpan);\n  }\n\n  // An alias for name, which allows other logic to handle property reads and keyed reads together.\n  get index() {\n    return this.name;\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return (\n      e instanceof ReadPropExpr && this.receiver.isEquivalent(e.receiver) && this.name === e.name\n    );\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitReadPropExpr(this, context);\n  }\n\n  set(value: Expression): WritePropExpr {\n    return new WritePropExpr(this.receiver, this.name, value, null, this.sourceSpan);\n  }\n\n  override clone(): ReadPropExpr {\n    return new ReadPropExpr(this.receiver.clone(), this.name, this.type, this.sourceSpan);\n  }\n}\n\nexport class ReadKeyExpr extends Expression {\n  constructor(\n    public receiver: Expression,\n    public index: Expression,\n    type?: Type | null,\n    sourceSpan?: ParseSourceSpan | null,\n  ) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return (\n      e instanceof ReadKeyExpr &&\n      this.receiver.isEquivalent(e.receiver) &&\n      this.index.isEquivalent(e.index)\n    );\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitReadKeyExpr(this, context);\n  }\n\n  set(value: Expression): WriteKeyExpr {\n    return new WriteKeyExpr(this.receiver, this.index, value, null, this.sourceSpan);\n  }\n\n  override clone(): ReadKeyExpr {\n    return new ReadKeyExpr(this.receiver.clone(), this.index.clone(), this.type, this.sourceSpan);\n  }\n}\n\nexport class LiteralArrayExpr extends Expression {\n  public entries: Expression[];\n  constructor(entries: Expression[], type?: Type | null, sourceSpan?: ParseSourceSpan | null) {\n    super(type, sourceSpan);\n    this.entries = entries;\n  }\n\n  override isConstant() {\n    return this.entries.every((e) => e.isConstant());\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof LiteralArrayExpr && areAllEquivalent(this.entries, e.entries);\n  }\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitLiteralArrayExpr(this, context);\n  }\n\n  override clone(): LiteralArrayExpr {\n    return new LiteralArrayExpr(\n      this.entries.map((e) => e.clone()),\n      this.type,\n      this.sourceSpan,\n    );\n  }\n}\n\nexport class LiteralMapEntry {\n  constructor(\n    public key: string,\n    public value: Expression,\n    public quoted: boolean,\n  ) {}\n  isEquivalent(e: LiteralMapEntry): boolean {\n    return this.key === e.key && this.value.isEquivalent(e.value);\n  }\n\n  clone(): LiteralMapEntry {\n    return new LiteralMapEntry(this.key, this.value.clone(), this.quoted);\n  }\n}\n\nexport class LiteralMapExpr extends Expression {\n  public valueType: Type | null = null;\n  constructor(\n    public entries: LiteralMapEntry[],\n    type?: MapType | null,\n    sourceSpan?: ParseSourceSpan | null,\n  ) {\n    super(type, sourceSpan);\n    if (type) {\n      this.valueType = type.valueType;\n    }\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof LiteralMapExpr && areAllEquivalent(this.entries, e.entries);\n  }\n\n  override isConstant() {\n    return this.entries.every((e) => e.value.isConstant());\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitLiteralMapExpr(this, context);\n  }\n\n  override clone(): LiteralMapExpr {\n    con